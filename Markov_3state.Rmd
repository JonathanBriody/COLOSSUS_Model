---
title: 'Exploratory Cost-Effectiveness Analysis of HDX Assayased on New Diagnostic Tests vs Standard of Care in Microsatellite Stable RAS Mutant Metastatic Colorectal Cancer Patients'
author: "Jonathan Briody (1) | Kathleen Bennett (1)"
output:
  html_document: default
  pdf_document: default
editor_options: 
  markdown: 
    wrap: sentence
bibliography: references.bib
---

(1) Data Science Centre, RCSI University of Medicine and Health Sciences, Dublin, Ireland

**Correspondence:**

Jonathan Briody, PhD, RCSI University of Medicine and Health Sciences, Beaux Lane House, Lower Mercer St, Dublin 2, Ireland.
Email: [jonathanbriody\@rcsi.ie](mailto:jonathanbriody@rcsi.ie){.email}

**Funding Information:**

This project has received funding from the European Union's Horizon 2020 research and innovation programme under grant agreement No 754923.
The material presented and views expressed here are the responsibility of the author(s) only.
The EU Commission takes no responsibility for any use made of the information set out.

\newpage

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, eval = T)
# To knit this document every time it is run, you can change `eval` to `TRUE` in the above.
```

```{r}
rm(list = ls())  
# clear memory (removes all the variables from the work space)
```

# 01 Load packages

```{r}
if (!require('pacman')) install.packages('pacman'); library(pacman) 
# use this package to conveniently install other packages
# load (install if required) packages from CRAN
p_load("diagram", "dampack") 
# install_github("DARTH-git/darthtools", force = TRUE) Uncomment if there is a newer version
p_load_gh("DARTH-git/darthtools")
```

# 02 Load functions

```{r}
# all functions are in the darthtools package
```

# 03 Input model parameters

```{r}
## General setup
# Here we define all our model parameters, so that we can call on these parameters later during our model:

n_cycles        <- 60                            
# We set the number of cycles to 60 to reflect 5 years broken down into monthly cycles
v_names_cycles  <- paste("cycle", 0:n_cycles)    
# So here, we just name each cycle by the cycle its on, going from o up to the number of cycles there are, here 60.
v_names_states  <- c("PFS", "OS", "Dead")  
# These are the health states in our model, PFS, OS, Death.
n_states        <- length(v_names_states)        
# We're just taking the number of health states from the number of names we came up with, i.e. 3 names to reflect three health states 

# Strategy names
v_names_str     <- c("Standard of Care",         
                     "EPI Assay", ## AKA Treatment A
                     "HDX Assay") ## AKA Treatment B 
# store the strategy names
n_str           <- length(v_names_str)           
# number of strategies


## Transition probabilities
p_HS_SoC  <- 0.05  # probability of becoming OS when PFS, conditional on surviving, under standard of care
p_HS_trtA <- 0.04  # probability of becoming OS when PFS, conditional on surviving, under EPI Assay
p_HS_trtB <- 0.02  # probability of becoming OS when PFS, conditional on surviving, under HDX Assay
p_SD      <- 0.1   # probability of dying          
p_HD      <- 0.01  # probability of dying when PFS


# I'M NOT DELIGHTED ABOUT USING CONDITIONAL PROBABILITIES ACTUALLY, AND WILL UPDATE THE ABOVE WITH THE WAY I CALCULATED PROBABILITIES WHEN DOING THE YORK COURSE I THINK.

# That will mean that when I'm on the section below:

# Fill in the transition probability matrix:

# I'll have to change how these probabilities are filled in.


# H = HEALTHY (PFS) -> HS MEANS HEALTHY TO SICK, HD -> MEANS HEALTHY TO DEAD.
# S = SICK (OS) -> SD MEANS SICK TO DEAD.
# D = DEAD (DEAD) 

# trtA -> Means the first intervention I am studying, i.e. treatment A or the first assay.
# trtB -> Means the second intervention I am studying, i.e. treatment B or the second assay.

# To add age specific mortality to our model, we would use this #03 input model parameters of:

# "C:\Users\Jonathan\OneDrive - Royal College of Surgeons in Ireland\COLOSSUS\Training Resources\Decision Modeling for Public Health_DARTH\5_Nov_29\4_Cohort state-transition models (cSTM) - time-dependent models_material\Markov_3state_time"

# with the 55 minute mark of: C:\Users\Jonathan\OneDrive - Royal College of Surgeons in Ireland\COLOSSUS\Training Resources\Cost-Effectiveness and Decision Modeling using R Workshop _ DARTH\August_24\Live Session Recording\Live Session Recording August 24th.mp4

# and this would allow us to create a vector of transition probabilities for p_HD above, i.e., from PFS to dead, that is a little bit larger at each cycle, starting at our chosen minimum value at the first cycle and increasing each cycle until it reaches our chosen maximum value at the last cycle.

# Alternatively, C:\Users\Jonathan\OneDrive - Royal College of Surgeons in Ireland\COLOSSUS\Training Resources\Cost-Effectiveness and Decision Modeling using R Workshop _ DARTH\August_24\4_cSTM - time-dependent models_material shows you how to use a life-table, as does the material from the York course, but I really think there's no need to get that detailed in our own analysis.


## Health State Values (AKA State rewards)
# Costs and utilities  
# Basically the outcomes we are interested in coming out of this model, so we'll look at the cohorts costs over the time horizon and the quality adjusted life years in our cohort over this time horizon.

c_H       <- 400   # cost of one cycle in PFS state
c_S       <- 1000  # cost of one cycle in OS state
c_D       <- 0     # cost of one cycle in dead state

# Above is the cost for each state, PFS, OS and dead,

c_trtA    <- 800   # cost of EPI Assay (per cycle) in PFS state
c_trtB    <- 1500  # cost of HDX Assay (per cycle) in PFS state

# We make the cost of EPI Assaybove so that when we have treatment strategies we can add this cost of treatment to anyone whose being treated when they receive the treatment.

u_H       <- 1     # utility when PFS 
u_S       <- 0.5   # utility when OS
u_D       <- 0     # utility when dead

# Then we define the utilities per health states.


# Discounting factors
d_c             <- 0.03                          
# discount rate for costs
d_e             <- 0.03                          
# discount rate for QALYs

# discount rate per cycle equal discount of costs and QALYs by 3%

# Discount weight (equal discounting is assumed for costs and effects)
v_dwc <- 1 / (1 + d_c) ^ (0:n_cycles) 
v_dwe <- 1 / (1 + d_e) ^ (0:n_cycles) 

# So, we create a discount weight vector above, to understand the way this works I'll have to return to my York notes on discounting


```

Discount rate for costs and utilities I've set as 3% here, I need to return to this and set it as 4%.
I also need to return to it more generally with the notes I wrote from York on discounting.
Also I set up 3 strategies, i.e. standard of care, EPI Assay and HDX Assay, to reflect the two assays under study, but it would be very easy to change this to just 2 strategies above.

I also want to add in the costing per the York model, as this broke costs down before adding them, although I can compare this to the York approach to costing in their published article, i.e. are costs in that article combined before they are added to the model or afterwards?

There are some things that I would like to appear in the code chunks, but not in the knitted document.
To do this I can go to:

<https://stackoverflow.com/questions/47710427/how-to-show-code-but-hide-output-in-rmarkdown>

and

<https://stackoverflow.com/questions/48286722/rmarkdown-how-to-show-partial-output-from-chunk?rq=1>

Although I can probably just use:

knitr::opts_chunk\$set(echo = TRUE, warning = FALSE, message = FALSE, eval = T)

But set echo = false

## Draw the state-transition cohort model

```{r}
m_P_diag <- matrix(0, nrow = n_states, ncol = n_states, dimnames = list(v_names_states, v_names_states))
m_P_diag["PFS", "OS" ]     = "" 
m_P_diag["PFS", "Dead" ]     = ""
m_P_diag["PFS", "PFS" ]  = ""
m_P_diag["OS"   , "Dead" ]     = ""
m_P_diag["OS"   , "OS" ]     = ""
m_P_diag["Dead"   , "Dead" ]     = ""
layout.fig <- c(2, 1)
plotmat(t(m_P_diag), t(layout.fig), self.cex = 0.5, curve = 0, arr.pos = 0.8,  
        latex = T, arr.type = "curved", relsize = 0.85, box.prop = 0.8, 
        cex = 0.8, box.cex = 0.7, lwd = 1)
```

# 04 Define and initialize matrices and vectors

After setting up our parameters above, we initialise our structure below.

This is where we will store all of the model output, and all the things that we need to track over time as we are simulating the progression of this cohort through this disease process.

## 04.1 Cohort trace

```{r}
## Initial state vector
# We create an inital vector where people start, with everyone (1 = 100% of people) starting in PFS below:
v_s_init <- c("PFS" = 1, "OS" = 0, "Dead" = 0)  
v_s_init

# There are cases where you can have an initial illness prevalence, so you would start some people in the sick state and some people in the healthy state, but above we're looking at people with mCRC, so we'll start everyone in PFS.



## Initialize cohort trace for cSTM (cohort state transition model) for all strategies (the strategies are the treatment strategies SOC, treatment A and Treatment B).
# So, basically we are creating a matrix to trace how the cohort is distributed across the health states, over time. 

# A matrix is necessary because there are basically two dimensions to this, the number of time cycles, which will be our rows, and then the number of states - to know which proportion of our cohort is in each state at each time:

m_M_SoC <- matrix(0, 
                  nrow = (n_cycles + 1), ncol = n_states, 
                  dimnames = list(v_names_cycles, v_names_states))
# Store the initial state vector in the first row of the cohort trace
m_M_SoC[1, ] <- v_s_init
## Initialize cohort traces
## So, above I made the cohort trace for standard of care, because in my analysis all my patients start in the PFS state, I can duplicate that below to create the cohort trace for treatment A and treatment B.
m_M_trtA <- m_M_trtB <- m_M_SoC # structure and initial states remain the same

# This gives us three matrices, m_M_trtA, m_M_trtB and m_M_SoC, that we can fill in with out simulations of how patients transitions between health states under each treatment strategy.

```

## 04.2 Transition probability matrix

```{r}

## If there were time varying transition probabilities, i.e. the longer you are in the model there are changes in your transition probability into death as you get older, etc., you would build a transition probability array, rather than a transition probability matrix, per: 

# 04.2 of:

# "C:\Users\Jonathan\OneDrive - Royal College of Surgeons in Ireland\COLOSSUS\Training Resources\Decision Modeling for Public Health_DARTH\5_Nov_29\4_Cohort state-transition models (cSTM) - time-dependent models_material\Markov_3state_time"

# with the 1hour: 02minute mark of: C:\Users\Jonathan\OneDrive - Royal College of Surgeons in Ireland\COLOSSUS\Training Resources\Cost-Effectiveness and Decision Modeling using R Workshop _ DARTH\August_24\Live Session Recording\Live Session Recording August 24th.mp4


## Initialize transition probability matrix, [i.e. build the framework or empty scaffolding of the transition probability matrix]
# all transitions to a non-death state are assumed to be conditional on survival 
m_P_SoC  <- matrix(0,
                   nrow = n_states, ncol = n_states,
                   dimnames = list(v_names_states, v_names_states)) # define row and column names
m_P_SoC
```

Fill in the transition probability matrix:

```{r}
## Standard of Care
# from PFS
m_P_SoC["PFS", "PFS"] <- (1 - p_HD) * (1 - p_HS_SoC)

# It's 1- p_HD, because if you're not going from healthy to dead then you're staying in healthy (i.e. you're not going from PFS to Dead, so you're staying in PFS) so this captures all the people leftover in PFS after those going to dead, and again for 1- p_HS_SoC, if you're not going from healthy to sick, the only other way out of healthy per the transition probability matrix, then you're staying in PFS, so 1- p_HS_SoC takes away all the people who went from healthy to sick, and leaves behind all the people who stayed in healthy (or takes away all the people who went to OS and leaves behind all the people that went to PFS per my model).

m_P_SoC["PFS", "OS"]    <- (1 - p_HD) *      p_HS_SoC

# This is because, when setting up the input parameters we didn't have a value for staying in progression free survival, so we have to calculate it, i.e. above we have to get the probability for going from PFS to OS, by getting all the people left in PFS after the people who went to death were gone, and then we multiply this probability by the probability of going from healthy to sick, or PFS to OS, because it's the probability conditional on being alive, the probability conditional on being left in the PFS state after the other people who went to the death state are gone, so the probability of going from PFS to OS, conditional on surviving.


m_P_SoC["PFS", "Dead"]    <-      p_HD

# Your probability of going from healthy to dead is not conditional on surviving, per the input parameters section.


# from OS
m_P_SoC["OS", "OS"] <- 1 - p_SD
m_P_SoC["OS", "Dead"] <-     p_SD

# Per the input parameters, your probability of going from sick to dead is also not conditional on surviving, so we dont need to multiply our probability conditional on surviving by the number of survivors as above.

# That's why though, our PFS to OS probability calculated through multiplication above is so close to the 0.05 in the input parameters, i.e. it's 0.0495, because we multiply it by 1 - p_HD or 1-0.01, which is basically multiplying it by a number very close to 1, so the probability remains very close to where it started off. The probability is conditional on the numbers of people in the alive state, we calculate that to be nearly 100% of people, so the probability remains the same. 


# m_P_SoC["PFS", "PFS"] <- (1 - p_HD) * (1 - p_HS_SoC)
# And the first one (commented out above) is the same, it's the probability of going from healthy to healthy which, because it's a conditional probability, is the number of individuals left in healthy multiplied by the probability of going from healthy to health conditional on surviving to be in healthy (so, to get a conditional probability we multiply the numbers who have survived by the probability -> here we don't have a probability for healthy to healthy, but we do have a probability for health to sick, so taking 1 - this gives us the probability of not going into sick, i.e. of staying in healthy instead). 

# from Dead
m_P_SoC["Dead", "Dead"] <- 1

# Once you're in dead you stay in dead, you can't come back to life.


# For handiness, we just take the treatment matrix that already exists for standard of care above, copy it as treatment A and treatment B, and then copy over it with new values specific to treatment A and treatment B, assuming that the probability of going from PFS to dead and staying in OS and going from OS to dead are the same as for standard of care (dead to dead is definitely the same as no one leaves dead) that's likely a reasonable assumption for our model, as once people progress we can assume they all go on to the same next treatment, standard of care progression treatment with the same likelihood of staying in OS and of going to the dead state, regardless of the novel therapy they were on:

## EPI Assay
m_P_trtA <- m_P_SoC
m_P_trtA["PFS", "PFS"] <- (1 - p_HD) * (1 - p_HS_trtA)
m_P_trtA["PFS", "OS"]    <- (1 - p_HD) *      p_HS_trtA

## HDX Assay
m_P_trtB <- m_P_SoC
m_P_trtB["PFS", "PFS"] <- (1 - p_HD) * (1 - p_HS_trtB)
m_P_trtB["PFS", "OS"]    <- (1 - p_HD) *      p_HS_trtB



# You can also think of it, per the 1hour: 05minute mark of: C:\Users\Jonathan\OneDrive - Royal College of Surgeons in Ireland\COLOSSUS\Training Resources\Cost-Effectiveness and Decision Modeling using R Workshop _ DARTH\August_24\Live Session Recording\Live Session Recording August 24th.mp4


# m_P_SoC["PFS", "OS"]    <- (1 - p_HD) [<- if you don't die] *      p_HS_SoC [then you have a risk of getting sick]

# It wont always be necessary to do this, i.e., to include conditional probabilities, it will depend on the data used and how things were estimated.

# This approach is taken for conditional probabilities, it's probably more relevant for modelling people to really, really old ages, where their mortality gets really high (so this is particularly relevant when you have age specific mortality), where you still have this high mortality of getting sick, you can end up in problems with the probabilities where the probability of leaving the state gets too high, because you haven't properly adjusted for these really high mortality rates, as people get really old.

# So, what this is doing is saying, if you don't die, then it's the remaining people who experience the probability of getting sick, so you're not adding probabilities together, which can be problematic, because sometimes you can have probabilities come to greater than one (i.e., larger than 100%).

# It's always worth considering, if you're extrapolating this risk of illness that's pretty high, on top of a cohort that also has a high risk of death, maybe that's not the right extrapolation, but this is another kind of fail safe to avoid that.

# Depending on how the data is estimated, this a correct interpretation of the probability estimate of going from one state to another (p_HS_SoC, or healthy to sick, or PFS to OS). 

```

I probably want to get rid of the conditional probabilities above, replacing them with standard transition probabilities per my York training.

Check if transition probability matrices are valid.

```{r}
# This is a check in the DARTH tools package that all the transition probabilities are in [0, 1], i.e., no probabilities are greater than 100%.
check_transition_probability(m_P_SoC,  verbose = TRUE)
check_transition_probability(m_P_trtA, verbose = TRUE)
check_transition_probability(m_P_trtB, verbose = TRUE)
# Check that all rows sum in each matrix sum to 1 - which we know is a necessary condition for transition probability matrices.
check_sum_of_transition_array(m_P_SoC,  n_states = n_states, verbose = TRUE)
check_sum_of_transition_array(m_P_trtA, n_states = n_states, verbose = TRUE)
check_sum_of_transition_array(m_P_trtB, n_states = n_states, verbose = TRUE)
```

# 05 Run Markov model

```{r}
for (t in 1:n_cycles){  # Use a for loop to loop through the number of cycles, basically we'll calculate the cohort distribution at the next cycle [t+1] based on the matrix of where they were at time t, matrix multiplied by the transition probability matrix for the current cycle (constant for us as we use a constant transition probability matrix, rather than a transition probability array).
# We do this for each treatment, as they all have different transition probability matrices. 
  m_M_SoC [t + 1, ] <- m_M_SoC [t, ] %*% m_P_SoC   # estimate the state vector for the next cycle (t + 1)
  m_M_trtA[t + 1, ] <- m_M_trtA[t, ] %*% m_P_trtA  # estimate the state vector for the next cycle (t + 1)
  m_M_trtB[t + 1, ] <- m_M_trtB[t, ] %*% m_P_trtB  # estimate the state vector for the next cycle (t + 1)
}
head(m_M_SoC)  # print the first few lines of the matrix for standard of care (m_M_SoC)
```

# 06 Compute and Plot Epidemiological Outcomes

## 06.1 Cohort trace

```{r}

# So, we'll plot the above Markov model for standard of care (m_M_SoC) to show our cohort distribution over time, i.e. the proportion of our cohort in the different health states over time.

matplot(m_M_SoC, type = 'l', 
        ylab = "Probability of state occupancy",
        xlab = "Cycle",
        main = "Cohort Trace", lwd = 3)  # create a plot of the data
legend("right", v_names_states, col = c("black", "red", "green"), 
       lty = 1:3, bty = "n")  # add a legend to the graph

# plot a vertical line that helps identifying at which cycle the prevalence of OS is highest
abline(v = which.max(m_M_SoC[, "OS"]), col = "gray")  
```







## 06.2 Overall Survival (OS)

```{r}
v_os <- 1 - m_M_SoC[, "Dead"]    # calculate the overall survival (OS) probability
v_os <- rowSums(m_M_SoC[, 1:2])  # alternative way of calculating the OS probability   

plot(v_os, type = 'l', 
     ylim = c(0, 1),
     ylab = "Survival probability",
     xlab = "Cycle",
     main = "Overall Survival")  # create a simple plot showing the OS

# add grid 
grid(nx = n_cycles, ny = 10, col = "lightgray", lty = "dotted", lwd = par("lwd"), 
     equilogs = TRUE) 
```

## 06.2.1 Life Expectancy (LE)

```{r}
v_le <- sum(v_os)  # summing probability of OS over time  (i.e. life expectancy)
```

## 06.3 Disease prevalence

```{r}
v_prev <- m_M_SoC[, "OS"]/v_os
plot(v_prev,
     ylim = c(0, 1),
     ylab = "Prevalence",
     xlab = "Cycle",
     main = "Disease prevalence")
```

# 07 Compute Cost-Effectiveness Outcomes

## 07.1 Mean Costs and QALYs

```{r}
# per cycle
# calculate expected costs by multiplying cohort trace with the cost vector for the different health states   
v_tc_SoC  <- m_M_SoC  %*% c(c_H, c_S, c_D)  
v_tc_trtA <- m_M_trtA %*% c(c_H + c_trtA, c_S, c_D)  
v_tc_trtB <- m_M_trtB %*% c(c_H + c_trtB, c_S, c_D)  

# calculate expected QALYs by multiplying cohort trace with the utilities for the different health states   
v_tu_SoC  <- m_M_SoC  %*% c(u_H, u_S, u_D)  
v_tu_trtA <- m_M_trtA %*% c(u_H, u_S, u_D) 
v_tu_trtB <- m_M_trtB %*% c(u_H, u_S, u_D) 
```

## 07.2 Discounted Mean Costs and QALYs

```{r}
# Discount costs by multiplying the cost vector with discount weights (v_dwc) 
tc_d_SoC  <-  t(v_tc_SoC)  %*% v_dwc
tc_d_trtA <-  t(v_tc_trtA) %*% v_dwc
tc_d_trtB <-  t(v_tc_trtB) %*% v_dwc

# Discount QALYS by multiplying the QALYs vector with discount weights (v_dwe)
tu_d_SoC  <-  t(v_tu_SoC)  %*% v_dwe
tu_d_trtA <-  t(v_tu_trtA) %*% v_dwe
tu_d_trtB <-  t(v_tu_trtB) %*% v_dwe

# Store them into a vector
v_tc_d <- c(tc_d_SoC, tc_d_trtA, tc_d_trtB)
v_tu_d <- c(tu_d_SoC, tu_d_trtA, tu_d_trtB)

# Dataframe with discounted costs and effectiveness
df_ce <- data.frame(Strategy = v_names_str,
                    Cost     = v_tc_d, 
                    Effect   = v_tu_d)
df_ce
```

## 07.3 Compute ICERs of the Markov model

```{r}
df_cea <- calculate_icers(cost       = df_ce$Cost,
                          effect     = df_ce$Effect,
                          strategies = df_ce$Strategy
                          )
df_cea
```

## 07.4 Plot frontier of the Markov model

```{r}
plot(df_cea, effect_units = "QALYs")
```

## References:

Useful Darth publications to cite when using this code:

-   Jalal H, Pechlivanoglou P, Krijkamp E, Alarid-Escudero F, Enns E, Hunink MG. An Overview of R in Health Decision Sciences.
    Med Decis Making.
    2017; 37(3): 735-746.
    <https://journals.sagepub.com/doi/abs/10.1177/0272989X16686559>

-   Alarid-Escudero F, Krijkamp EM, Enns EA, Yang A, Hunink MGM Pechlivanoglou P, Jalal H. Cohort State-Transition Models in R: A Tutorial.
    arXiv:200107824v2.
    2020:1-48.
    <http://arxiv.org/abs/2001.07824>

-   Krijkamp EM, Alarid-Escudero F, Enns EA, Jalal HJ, Hunink MGM, Pechlivanoglou P. Microsimulation modeling for health decision sciences using R: A tutorial.
    Med Decis Making.
    2018;38(3):400--22.
    <https://journals.sagepub.com/doi/abs/10.1177/0272989X18754513>

-   Krijkamp EM, Alarid-Escudero F, Enns E, Pechlivanoglou P, Hunink MM, Jalal H. A Multidimensional Array Representation of State-Transition Model Dynamics.
    Med Decis Making.
    Online First <https://doi.org/10.1177/0272989X19893973>
