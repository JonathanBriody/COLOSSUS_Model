# - note that S(t) = exp(-H(t)) and, hence, H(t) = -ln(S(t))
# that is, the survival function is the expoential of the negative hazard function, per:
# https://faculty.washington.edu/yenchic/18W_425/Lec5_survival.pdf
# and:
# https://web.stanford.edu/~lutian/coursepdf/unit1.pdf
# Also saved here: C:\Users\Jonathan\OneDrive - Royal College of Surgeons in Ireland\COLOSSUS\R Code\Parametric Survival Analysis\flexsurv
# And to multiply by the hazard ratio it's necessary to convert the survivor function into the hazard function, multiply by the hazard ratio, and then convery back to the survivor function, and then these survivor functions are used for the probabilities.
HR_PD_Exp <- 0.6
H_PD_SoC  <- -log(S_PD_SoC)
H_PD_Exp  <- H_PD_SoC * HR_PD_Exp
S_PD_Exp  <- exp(-H_PD_Exp)
head(cbind(t, S_PD_SoC, H_PD_SoC, H_PD_Exp, S_PD_Exp))
# If I decide that, as I said,  once you get into the OS state under the experimental strategy, you recieve the same second-line treatment as standard of care again and thus your event-free (i.e. overall survival) probabilities for the cycle times are the same as for SoC, then I can use the following coding - which is just repeating what I did for standard of care but this time giving it to the experimental stratgey:
S_PD_Exp <- pweibull(
q     = t,
shape = exp(coef_TTD_weibull_shape_SoC),
scale = exp(coef_TTD_weibull_scale_SoC),
lower.tail = FALSE
)
head(cbind(t, S_PD_Exp))
# I've coded in both options here and I can make a decision when applying this.
# 4) Obtaining the time-dependent transition probabilities from the event-free (i.e. overall survival) probabilities
# Now we can take the probability of being in the OS state at each of our cycles, as created above, from 100% (i.e. from 1) in order to get the probability of NOT being in the OS state, i.e. in order to get the probability of moving into the deda state.
p_PD_SoC <- p_PD_Exp <- rep(NA, n_cycle)
# First we make the probability of going from progression (P) to dead (D) blank (i.e. NA) for all the cycles in standard of care and all the cycles under the experimental strategy.
for(i in 1:n_cycle) {
p_PD_SoC[i] <- 1 - S_PD_SoC[i+1] / S_PD_SoC[i]
p_PD_Exp[i] <- 1 - S_PD_Exp[i+1] / S_PD_Exp[i]
}
# Then we generate our transition probability under standard of care and under the experimental treatement using survival functions that havent and have had the hazard ratio from above applied to them, respectively. [If we decide not to apply a hazard ratio for the experimental strategy going from progression to dead then neither may have a hazard ratio applied to them].
# The way this works is, you take next cycles probability of staying in this state, divide it by this cycles probability of staying in this state, and take it from 1 to get the probability of leaving this state.
p_PD_SoC
p_PD_Exp
# Time-constant transition probabilities [ADVERSE EVENTS]:
# To create transition probabilities from longer time periods I can use the information in this email to Daniel:
# Inquiry re: Cost effectiveness analysis of pharmacokinetically-guided 5-fluorouracil in FOLFOX chemotherapy for metastatic colorectal cancer
# - https://outlook.office.com/mail/id/AAQkAGI5OWU0NTJkLTEzMjgtNGVhOS04ZGZiLWZkOGU1MDg3ZmE5MAAQAHQCBS2m%2B%2FVAjAc%2FWSCjQEQ%3D
# There may also be some relevant information in the below:
## Transition probabilities and hazard ratios
# "Note: To calculate the probability of dying from S1 and S2, use the hazard ratios provided. To do so, first convert the probability of dying from healthy, p_HD , to a rate; then multiply this rate by the appropriate hazard ratio; finally, convert this rate back to a probability. Recall that you can convert between rates and probabilities using the following formulas: r = − log(1 − p) and p = 1 − e ( − rt ) . The package darthtools also has the functions prob_to_rate and rate_to_prob that might be of use to you." per: C:\Users\Jonathan\OneDrive - Royal College of Surgeons in Ireland\COLOSSUS\Training Resources\Cost-Effectiveness and Decision Modeling using R Workshop _ DARTH\August_25\3_cSTM - history dependence_material\Download exercise handout
# ?rate_to_prob will tell you more about this function.
# ?prob_to_rate will tell you more about this function.
# As will the 50 minute mark of: C:\Users\Jonathan\OneDrive - Royal College of Surgeons in Ireland\COLOSSUS\Training Resources\Cost-Effectiveness and Decision Modeling using R Workshop _ DARTH\August_25\Live Session Recording\Live Session Recording August 25th WITH CHAT.mkv
# The above also describes how to convert probabilities for different time scales, i.e., convert a probability for 5 years to 1 year, etc., and how to convert data that exists as a rate to a probability for use in a Markov model.
# The intial probabilities before I decided to do parametric survival analysis:
# p_HS_SoC  <- 0.05  # probability of becoming OS when PFS, conditional on surviving, under standard of care
# p_HS_trtA <- 0.04  # probability of becoming OS when PFS, conditional on surviving, under EPI Assay
# p_HS_trtB <- 0.02  # probability of becoming OS when PFS, conditional on surviving, under HDX Assay
# p_SD      <- 0.1   # probability of dying
# p_HD      <- 0.01  # probability of dying when PFS
# H = HEALTHY (PFS) -> HS MEANS HEALTHY TO SICK, HD -> MEANS HEALTHY TO DEAD.
# S = SICK (OS) -> SD MEANS SICK TO DEAD.
# D = DEAD (DEAD)
# trtA -> Means the first intervention I am studying, i.e. treatment A or the first assay.
# trtB -> Means the second intervention I am studying, i.e. treatment B or the second assay.
# To add age specific mortality to our model, we would use this #03 input model parameters of:
# "C:\Users\Jonathan\OneDrive - Royal College of Surgeons in Ireland\COLOSSUS\Training Resources\Decision Modeling for Public Health_DARTH\5_Nov_29\4_Cohort state-transition models (cSTM) - time-dependent models_material\Markov_3state_time"
# with the 55 minute mark of: C:\Users\Jonathan\OneDrive - Royal College of Surgeons in Ireland\COLOSSUS\Training Resources\Cost-Effectiveness and Decision Modeling using R Workshop _ DARTH\August_24\Live Session Recording\Live Session Recording August 24th.mp4
# and this would allow us to create a vector of transition probabilities for p_HD above, i.e., from PFS to dead, that is a little bit larger at each cycle, starting at our chosen minimum value at the first cycle and increasing each cycle until it reaches our chosen maximum value at the last cycle.
# Alternatively, C:\Users\Jonathan\OneDrive - Royal College of Surgeons in Ireland\COLOSSUS\Training Resources\Cost-Effectiveness and Decision Modeling using R Workshop _ DARTH\August_24\4_cSTM - time-dependent models_material shows you how to use a life-table, as does the material from the York course, but I really think there's no need to get that detailed in our own analysis.
# Now that I am doing parametric survival analysis, the only probabilities I need to generate here are the adverse event probabilities, I generate them as conditional probabilities per chunk 20:
# Probability of going to the adverse event state from the progression free state:
p_FA1_STD     <- 0.02   # probability of adverse event 1 when progression-free under SOC
p_A1_D_STD    <- 0.1    # probability of dying when in adverse event 1 under SOC
p_FA2_STD     <- 0.02   # probability of adverse event 2 when progression-free under SOC
p_A2_D_STD    <- 0.1    # probability of dying when in adverse event 2 under SOC
p_FA3_STD     <- 0.02   # probability of adverse event 3 when progression-free under SOC
p_A3_D_STD    <- 0.1    # probability of dying when in adverse event 3 under SOC
p_FA1_EXPR     <- 0.02   # probability of adverse event 1 when progression-free under EXPR
p_A1_D_EXPR    <- 0.1    # probability of dying when in adverse event 1 under EXPR
p_FA2_EXPR     <- 0.02   # probability of adverse event 2 when progression-free under EXPR
p_A2_D_EXPR    <- 0.1    # probability of dying when in adverse event 2 under EXPR
p_FA3_EXPR     <- 0.02   # probability of adverse event 3 when progression-free under EXPR
p_A3_D_EXPR    <- 0.1    # probability of dying when in adverse event 3 under EXPR
p_PD_SoC
p_PD_Exp
p_FP_SoC
p_FP_Exp
p_FD_SoC   <- 0.02 # Probability of dying when progression-free:
p_FD_Exp   <- 0.02 # Probability of dying when progression-free:
# When digitising a progression-free survival curve everyone on that curve is on PFS, and if they leave that curve it is because their disease has progressed (so they've gone from progression free to progression, or from PFS to OS) or they've died:
# "Progression-free survival (PFS) is defined as the time from random assignment in a clinical trial to disease progression or death from any cause." https://www.ncbi.nlm.nih.gov/books/NBK137763/
# "Progression-free survival (PFS) is "the length of time during and after the treatment of a disease, such as cancer, that a patient lives with the disease but it does not get worse". https://en.wikipedia.org/wiki/Progression-free_survival#:~:text=Progression-free%20survival%20(PFS),it%20does%20not%20get%20worse".
# Time to Progression:
# "The length of time from the date of diagnosis or the start of treatment for a disease until the disease starts to get worse or spread to other parts of the body. In a clinical trial, measuring the time to progression is one way to see how well a new treatment works. Also called TTP." https://www.cancer.gov/publications/dictionaries/cancer-terms/def/time-to-progression
# Koen's data is time to progression data, so we can't figure out time to death from it. It may be possible to do this with the data I end up using, or as advised by the C:\Users\Jonathan\OneDrive - Royal College of Surgeons in Ireland\COLOSSUS\R Code\Parametric Survival Analysis\flexsurv folder, but at the moment I'll just set PFS to Dead as a time-constant transition probability as he does.
# PFS -> PFS:
p_PFS_SoC  <-   (1 - p_FD_SoC) * (1 - p_FP_SoC)
p_PFS_Exp  <-   (1 - p_FD_Exp) * (1 - p_FP_Exp)
# First, I need to create progression free survival probabilities under standard of care.
# It's 1- p_FD_SoC, because if you're not going from healthy to dead then you're staying in healthy (i.e. you're not going from PFS to Dead, so you're staying in PFS) so this captures all the people leftover in PFS after those going to dead, and again for 1- p_FP_SoC, if you're not going from healthy to sick, the only other way out of healthy per the transition probability matrix, then you're staying in PFS, so 1- p_FP_SoC takes away all the people who went from healthy to sick, and leaves behind all the people who stayed in healthy (or takes away all the people who went to OS and leaves behind all the people that went to PFS per my model).
# PFS -> OS:
p_PFS_OS_SoC    <- (1 - p_FD_SoC) *      p_FP_SoC
p_PFS_OS_Exp    <- (1 - p_FD_Exp) *      p_FP_Exp
# We have to get the probability for going from PFS to OS, by getting all the people left in PFS after the people who went to death were gone, and then we multiply this probability by the probability of going from healthy to sick, or PFS to OS, because it's the probability conditional on being alive, the probability conditional on being left in the PFS state after the other people who went to the death state are gone, so the probability of going from PFS to OS, conditional on surviving.
# p_PFS_OS_SoC is the probability of transitioning from healthy to sick, conditional on surviving, so it's defined as a conditional probability. So, what the Markov model wants is : m_P_SoC["PFS", "OS"] what's the overall probability of transitioning from PFS to OS, and so that is actually not a conditional probability, which is why we multiply the probability of surviving (1 - p_HD) *      p_HS_SoC by the probability of going to OS conditional on surviving, because the transition in the model should be the marginal not the conditional, i.e. you want to have the end probability.
#So, because you took a probability that was conditional from the literature, or digitised a PFS curve to get a transition probability - and those probabilities come from people who were necessarily still in the PFS state when you digitise a PFS curve, so those are transition probabilities conditional on being in the PFS (or healthy) state - you need to do the multiplication to give you a probability you can put in your transition matrix that reflects that the probability you are working with is conditional.
# Adverse event transition probabilities have all been conditional, this is to reflect that probabilities on transitioning from adverse event to death will necessarily be conditional probabilities - as they come from individuals who were studied in the adverse event group - so they are necessarily probabilities conditional on experiencing the adverse event. Likewise, the probability of experiencing the adverse event when under treatment is conditional on being in PFS for the treatment in the first place, because it will come from reports of adverse events in studies of the treatments given that we look at.
# Which means conditional probabilities kind of don't matter too much, because the probability won't be applied to anyone who isnt in the state it doesnt necessarily need to be conditional after all. And I guess it would have never been applied to anyone who wasnt in the state, because probabilities are only applied to people who are in the state when the transition probability matrix is multiplied by the cohort trace of people in the state.
p_FA1_SoC  <- (p_PFS_SoC) * p_FA1_STD
# Probability of AE1 when PFS, conditional on surviving, under standard of care
p_A1D_SoC  <- 0.001
# Probability of going from AE1 to death, at the moment this is just a dummy value, I expect this to be a really low value source from the literature.
p_A1F_SoC  <- 1-p_A1D_SoC
# Probability of returning from AE1 to PFS is 100% minus the people who have gone into the dead state.
# I repeat this for the other adverse events and for both standard of care and the experimental (novel) treatment:
# Probability of A2 when PFS, conditional on surviving, under standard of care
p_FA2_SoC  <- (p_PFS_SoC) * p_FA2_STD
# Probability of going from A2 to death, at the moment this is just a dummy value, I expect this to be a really low value source from the literature.
p_A2D_SoC  <- 0.001
# Probability of returning from A2 to PFS is 100% minus the people who have gone into the dead state.
p_A2F_SoC  <- 1-p_A2D_SoC
# Probability of A3 when PFS, conditional on surviving, under standard of care
p_FA3_SoC  <- (p_PFS_SoC) * p_FA3_STD
# Probability of going from A3 to death, at the moment this is just a dummy value, I expect this to be a really low value source from the literature.
p_A3D_SoC  <- 0.001
# Probability of returning from A3 to PFS is 100% minus the people who have gone into the dead state.
p_A3F_SoC  <- 1-p_A3D_SoC
# Probability of A1 when PFS, conditional on surviving, under standard of care
p_FA1_Exp  <- (p_PFS_Exp) * p_FA1_EXPR
# Probability of going from A1 to death, at the moment this is just a dummy value, I expect this to be a really low value source from the literature.
p_A1D_Exp  <- 0.001
# Probability of returning from A1 to PFS is 100% minus the people who have gone into the dead state.
p_A1F_Exp  <- 1-p_A1D_Exp
# Probability of A2 when PFS, conditional on surviving, under standard of care
p_FA2_Exp  <- (p_PFS_Exp) * p_FA2_EXPR
# Probability of going from A2 to death, at the moment this is just a dummy value, I expect this to be a really low value source from the literature.
p_A2D_Exp  <- 0.001
# Probability of returning from A2 to PFS is 100% minus the people who have gone into the dead state.
p_A2F_Exp  <- 1-p_A2D_Exp
# Probability of A3 when PFS, conditional on surviving, under standard of care
p_FA3_Exp  <- (p_PFS_Exp) * p_FA3_EXPR
# Probability of going from A3 to death, at the moment this is just a dummy value, I expect this to be a really low value source from the literature.
p_A3D_Exp  <- 0.001
# Probability of returning from A3 to PFS is 100% minus the people who have gone into the dead state.
p_A3F_Exp  <- 1-p_A3D_Exp
# These all have to be conditional on survival, i.e. conditional on being in PFS, this is to ensure that I am only applying adverse events to the people still in the PFS, after transitions etc., have happened. --> This is not how conditional probabilities work, I have the correct interpretation of them elsewhere in this code file.
## Health State Values (AKA State rewards)
# Costs and utilities
# Basically the outcomes we are interested in coming out of this model, so we'll look at the cohorts costs over the time horizon and the quality adjusted life years in our cohort over this time horizon.
# Costs
c_F_SoC       <- 400   # cost of one cycle in PFS state under standard of care
c_F_Exp       <- 1000  # cost of one cycle in PFS state under the experimental treatment
c_F_Ex_trtA       <- 1000  # cost of one cycle in PFS state under the experimental treatment A
c_F_Ex_trtB       <- 1000  # cost of one cycle in PFS state under the experimental treatment
c_P       <- 1000  # cost of one cycle in progression state (I assume in OS everyone gets the same treatment so it costs everyone the same to be treated).
c_D       <- 0     # cost of one cycle in dead state
# We define the costs of the adverse events:
c_AE1 <- 100
c_AE2 <- 100
c_AE3 <- 100
# Above is the cost for each state, PFS, OS and dead,
# c_trtA    <- 800   # cost of EPI Assay in PFS state (ONCE OFF COST)
# c_trtB    <- 1500  # cost of HDX Assay in PFS state (ONCE OFF COST)
#
# # We make the cost of the assays above so that when we have treatment strategies we can add this cost of treatment to anyone whose being treated when they receive the treatment.
# Then we define the utilities per health states.
u_F       <- 0.8     # utility when PFS
u_P       <- 0.5   # utility when OS
u_D       <- 0     # utility when dead
# We define the utilities in the adverse event states:
u_AE1 <- 0.5
u_AE2 <- 0.5
u_AE3 <- 0.5
# Discounting factors
d_c             <- 0.04
# discount rate for costs (per year)
d_e             <- 0.04
# discount rate for QALYs (per year)
# discount rate per cycle equal discount of costs and QALYs by 4%
# Discount weight (equal discounting is assumed for costs and effects)
# Actually I've updated this and do this later on now
# v_dwc <- 1 / (1 + d_c) ^ (0:n_cycle)
# v_dwe <- 1 / (1 + d_e) ^ (0:n_cycle)
# So, we create a discount weight vector above, to understand the way this works I'll have to return to my York notes on discounting
diag_names_states  <- c("PFS", "OS", "AE1", "AE2", "AE3", "Dead")
m_P_diag <- matrix(0, nrow = n_states, ncol = n_states, dimnames = list(diag_names_states, diag_names_states))
m_P_diag["PFS", "OS" ]     = ""
m_P_diag["PFS", "Dead" ]     = ""
m_P_diag["PFS", "PFS" ]  = ""
m_P_diag["PFS", "AE1" ]     = ""
m_P_diag["PFS", "AE2" ]     = ""
m_P_diag["PFS", "AE3" ]     = ""
m_P_diag["OS", "Dead" ]     = ""
m_P_diag["OS", "OS" ]     = ""
m_P_diag["AE1", "PFS" ]     = ""
m_P_diag["AE2", "PFS" ]     = ""
m_P_diag["AE3", "PFS" ]     = ""
m_P_diag["AE1", "Dead" ]     = ""
m_P_diag["AE2", "Dead" ]     = ""
m_P_diag["AE3", "Dead" ]     = ""
m_P_diag["Dead", "Dead" ]     = ""
layout.fig <- c(1, 4, 1) # <- changing the numbers here changes the diagram layout, so mess with these until I'm happy. It basically decides how many bubbles will be on each level, so here 1 bubble, followed by 3 bubbles, followed by 2 bubbles, per the diagram for 1, 3, 2.
plotmat(t(m_P_diag), t(layout.fig), self.cex = 0.5, curve = 0, arr.pos = 0.64,
latex = T, arr.type = "curved", relsize = 0.85, box.prop = 0.9,
cex = 0.8, box.cex = 0.7, lwd = 0.6, main = "Figure 1")
# WHEN COMING BACK TO COMPARE: C:\Users\Jonathan\OneDrive - Royal College of Surgeons in Ireland\COLOSSUS\R Code\Parametric Survival Analysis\ISPOR WEBINAR Health Economic Modelling in R\ISPOR_webinar_R-master\ISPOR_webinar_R-master\oncologySemiMarkov_illustration to this Rmarkdown document, a big difference is that this document creates a cycle 0 - whereas the comparison from the ISPOR_webinar_R uses -1 to get into cycle 0 where necessary. I have decided to follow the ISPOR way, because I am interested in duplicating their parametric analysis, so I need to bear this difference in mind as I go through this document.
# Also, continue from Verbose in this and in Koens file
# Markov cohort trace matrix ----
# Initialize matrices to store the Markov cohort traces for each strategy
# - note that the number of rows is n_cycle + 1, because R doesn't use index 0 (i.e. cycle 0)  --> What we mean here, is that when we do our calculations later they need to be for cycle-1 to reflect cycle 0.
m_M_SoC <- m_M_Exp  <-  matrix(
data = NA,
nrow = n_cycle,
ncol = n_states,
dimnames = list(paste('Cycle', 1:n_cycle), v_names_states)
)
## Initial state vector
# We create an inital vector where people start, with everyone (1 = 100% of people) starting in PFS below:
# v_s_init <- c("PFS" = 1, "OS" = 0, "Dead" = 0)
# v_s_init
# There are cases where you can have an initial illness prevalence, so you would start some people in the sick state and some people in the healthy state, but above we're looking at people with mCRC, so we'll start everyone in PFS.
## Initialize cohort trace for cSTM (cohort state transition model) for all strategies (the strategies are the treatment strategies SOC, treatment A and Treatment B).
# So, basically we are creating a matrix to trace how the cohort is distributed across the health states, over time.
# A matrix is necessary because there are basically two dimensions to this, the number of time cycles, which will be our rows, and then the number of states - to know which proportion of our cohort is in each state at each time:
# m_M_SoC <- matrix(0,
#                   nrow = (n_cycles + 1), ncol = n_states,
#                   dimnames = list(v_names_cycles, v_names_states))
# Above instead of having to bother with -1 throughout the analysis they create a cycle 0.
# Store the initial state vector in the first row of the cohort trace
# m_M_SoC[1, ] <- v_s_init
## Initialize cohort traces
## So, above I made the cohort trace for standard of care, because in my analysis all my patients start in the PFS state, I can duplicate that below to create the cohort trace for treatment A and treatment B.
# m_M_trtA <- m_M_trtB <- m_M_SoC # structure and initial states remain the same
# This gives us three matrices, m_M_trtA, m_M_trtB and m_M_SoC, that we can fill in with our simulations of how patients transitions between health states under each treatment strategy.
# In the first row of the markov matrix [1, ] put the value at the far end, i.e. "<-1" and "<-0" under the colum "PFS" [ , "PFS"], repeating this for "OS", "AE1", "AE2" "AE3" and "Dead".
# Specifying the initial state for the cohorts (all patients start in PFS)
m_M_SoC[1, "PFS"] <- m_M_Exp[1, "PFS"] <- 1
m_M_SoC[1, "OS"]  <- m_M_Exp[1, "OS"]  <- 0
m_M_SoC[1, "AE1"] <- m_M_Exp[1, "AE1"] <- 0
m_M_SoC[1, "AE2"] <- m_M_Exp[1, "AE2"] <- 0
m_M_SoC[1, "AE3"] <- m_M_Exp[1, "AE3"] <- 0
m_M_SoC[1, "Dead"]<- m_M_Exp[1, "Dead"]  <- 0
# Inspect whether properly defined
head(m_M_SoC)
head(m_M_Exp)
#head(m_M_Exp_trtB)
## If there were time varying transition probabilities, i.e. the longer you are in the model there are changes in your transition probability into death as you get older, etc., you would build a transition probability array, rather than a transition probability matrix, per:
# 04.2 of:
# "C:\Users\Jonathan\OneDrive - Royal College of Surgeons in Ireland\COLOSSUS\Training Resources\Decision Modeling for Public Health_DARTH\5_Nov_29\4_Cohort state-transition models (cSTM) - time-dependent models_material\Markov_3state_time"
# with the 1hour: 02minute mark of: C:\Users\Jonathan\OneDrive - Royal College of Surgeons in Ireland\COLOSSUS\Training Resources\Cost-Effectiveness and Decision Modeling using R Workshop _ DARTH\August_24\Live Session Recording\Live Session Recording August 24th.mp4
## Initialize transition probability matrix, [i.e. build the framework or empty scaffolding of the transition probability matrix]
# all transitions to a non-death state are assumed to be conditional on survival
# - starting with standard of care
# - note that these are now 3-dimensional matrices because we are including time.
# m_P_SoC  <- matrix(0,
#                    nrow = n_states, ncol = n_states,
#                    dimnames = list(v_names_states, v_names_states)) # define row and column names
# m_P_SoC
# Initialize matrices for the transition probabilities
# - note that these are now 3-dimensional matrices (so, above we originally included dim = nrow and ncol, but now we also include n_cycle - i.e. the number of cycles).
# - starting with standard of care
m_P_SoC <- array(
data = 0,
dim = c(n_states, n_states, n_cycle),
dimnames = list(v_names_states, v_names_states, paste0("Cycle", 1:n_cycle))
# define row and column names - then name each array after which cycle it's for, i.e. cycle 1 all the way through to cycle 120. So Cycle 1 will have all of our patients in PFS, while cycle 120 will have most people in the dead state.
)
head(m_P_SoC)
m_P_Exp <- array(
data = 0,
dim = c(n_states, n_states, n_cycle),
dimnames = list(v_names_states, v_names_states, paste0("Cycle", 1:n_cycle))
# define row and column names - then name each array after which cycle it's for, i.e. cycle 1 all the way through to cycle 120. So Cycle 1 will have all of our patients in PFS, while cycle 120 will have most people in the dead state.
)
head(m_P_Exp)
# It looks like I will need to decide if I have to go back to the start of putting everything in the model and put stuff in for not just the experimental strategy, but for experimental strategy 1 AND experimental strategy 2 individually.
# Setting the transition probabilities from PFS based on the model parameters
# So, when individuals are in PFS what are their probabilities of going into the other states that they can enter from PFS?
m_P_SoC["PFS", "PFS", ] <- p_PFS_SoC
m_P_SoC["PFS", "OS", ]     <- p_PFS_OS_SoC
m_P_SoC["PFS", "AE1", ]     <- p_FA1_SoC
m_P_SoC["PFS", "AE2", ]     <- p_FA2_SoC
m_P_SoC["PFS", "AE3", ]     <- p_FA3_SoC
m_P_SoC["PFS", "Dead", ]            <- p_FD_SoC
# Setting the transition probabilities from OS
m_P_SoC["OS", "OS", ] <- 1 - p_PD_SoC
m_P_SoC["OS", "Dead", ]        <- p_PD_SoC
# Setting the transition probabilities from Dead
m_P_SoC["Dead", "Dead", ] <- 1
# Setting the transition probabilities from AE1
m_P_SoC["AE1", "PFS", ] <- p_A1F_SoC
m_P_SoC["AE1", "Dead", ] <- p_A1D_SoC
# Setting the transition probabilities from AE2
m_P_SoC["AE2", "PFS", ] <- p_A2F_SoC
m_P_SoC["AE2", "Dead", ] <- p_A2D_SoC
# Setting the transition probabilities from AE3
m_P_SoC["AE3", "PFS", ] <- p_A3F_SoC
m_P_SoC["AE3", "Dead", ] <- p_A3D_SoC
m_P_SoC
# Using the transition probabilities for standard of care as basis, update the transition probabilities that are different for the experimental strategy
m_P_Exp["PFS", "PFS", ] <- p_PFS_Exp
m_P_Exp["PFS", "OS", ]     <- p_PFS_OS_Exp
m_P_Exp["PFS", "AE1", ]     <- p_FA1_Exp
m_P_Exp["PFS", "AE2", ]     <- p_FA2_Exp
m_P_Exp["PFS", "AE3", ]     <- p_FA3_Exp
m_P_Exp["PFS", "Dead", ]            <- p_FD_Exp
# Setting the transition probabilities from OS
m_P_Exp["OS", "OS", ] <- 1 - p_PD_Exp
m_P_Exp["OS", "Dead", ]        <- p_PD_Exp
# Setting the transition probabilities from Dead
m_P_Exp["Dead", "Dead", ] <- 1
# Setting the transition probabilities from AE1
m_P_Exp["AE1", "PFS", ] <- p_A1F_Exp
m_P_Exp["AE1", "Dead", ] <- p_A1D_Exp
# Setting the transition probabilities from AE2
m_P_Exp["AE2", "PFS", ] <- p_A2F_Exp
m_P_Exp["AE2", "Dead", ] <- p_A2D_Exp
# Setting the transition probabilities from AE3
m_P_Exp["AE3", "PFS", ] <- p_A3F_Exp
m_P_Exp["AE3", "Dead", ] <- p_A3D_Exp
m_P_Exp
# An explanation of conditional probabilities:
## Standard of Care
# from PFS
# m_P_SoC["PFS", "PFS"] <- (1 - p_HD) * (1 - p_HS_SoC)
# It's 1- p_HD, because if you're not going from healthy to dead then you're staying in healthy (i.e. you're not going from PFS to Dead, so you're staying in PFS) so this captures all the people leftover in PFS after those going to dead, and again for 1- p_HS_SoC, if you're not going from healthy to sick, the only other way out of healthy per the transition probability matrix, then you're staying in PFS, so 1- p_HS_SoC takes away all the people who went from healthy to sick, and leaves behind all the people who stayed in healthy (or takes away all the people who went to OS and leaves behind all the people that went to PFS per my model).
# m_P_SoC["PFS", "OS"]    <- (1 - p_HD) *      p_HS_SoC
# This is because, when setting up the input parameters we didn't have a value for staying in progression free survival, so we have to calculate it, i.e. above we have to get the probability for going from PFS to OS, by getting all the people left in PFS after the people who went to death were gone, and then we multiply this probability by the probability of going from healthy to sick, or PFS to OS, because it's the probability conditional on being alive, the probability conditional on being left in the PFS state after the other people who went to the death state are gone, so the probability of going from PFS to OS, conditional on surviving.
# m_P_SoC["PFS", "OS"]    <- (1 - p_HD) *      p_HS_SoC
# p_HS_SoC is the probability of transitioning from healthy to sick, conditional on surviving, so it's defined as a conditional probability. So, what the Markov model wants is : m_P_SoC["PFS", "OS"] what's the overall probability of transitioning from PFS to OS, and so that is actually not a conditional probability, which is why we multiply the probability of surviving (1 - p_HD) *      p_HS_SoC by the probability of going to OS conditional on surviving, because the transition in the model should be the marginal not the conditional, i.e. you want to have the end probability.
#So, because you took a probability that was conditional from the literature, or digitised a PFS curve to get a transition probability - and those probabilities come from people who were necessarily still in the PFS state when you digitise a PFS curve, so those are transition probabilities conditional on being in the PFS (or healthy) state - you need to do the multiplication to give you a probability you can put in your transition matrix that reflects that the probability you are working with is conditional.
# Adverse event transition probabilities have all been conditional, this is to reflect that probabilities on transitioning from adverse event to death will necessarily be conditional probabilities - as they come from individuals who were studied in the adverse event group - so they are necessarily probabilities conditional on experiencing the adverse event. Likewise, the probability of experiencing the adverse event when under treatment is conditional on being in PFS for the treatment in the first place, because it will come from reports of adverse events in studies of the treatments given that we look at.
# Which means conditional probabilities kind of don't matter too much, because the probability won't be applied to anyone who isnt in the state it doesnt necessarily need to be conditional after all. And I guess it would have never been applied to anyone who wasnt in the state, because probabilities are only applied to people who are in the state when the transition probability matrix is multiplied by the cohort trace of people in the state.
# m_P_SoC["PFS", "Dead"]    <-      p_HD
# Your probability of going from healthy to dead is not conditional on surviving, per the input parameters section.
# from OS
# m_P_SoC["OS", "OS"] <- 1 - p_SD
# m_P_SoC["OS", "Dead"] <-     p_SD
# Per the input parameters, your probability of going from sick to dead is also not conditional on surviving, so we dont need to multiply our probability conditional on surviving by the number of survivors as above.
# That's why though, our PFS to OS probability calculated through multiplication above is so close to the 0.05 in the input parameters, i.e. it's 0.0495, because we multiply it by 1 - p_HD or 1-0.01, which is basically multiplying it by a number very close to 1, so the probability remains very close to where it started off. The probability is conditional on the numbers of people in the alive state, we calculate that to be nearly 100% of people, so the probability remains the same.
# m_P_SoC["PFS", "PFS"] <- (1 - p_HD) * (1 - p_HS_SoC)
# And the first one (commented out above) is the same, it's the probability of going from healthy to healthy which, because it's a conditional probability, is the number of individuals left in healthy multiplied by the probability of going from healthy to health conditional on surviving to be in healthy (so, to get a conditional probability we multiply the numbers who have survived by the probability -> here we don't have a probability for healthy to healthy, but we do have a probability for health to sick, so taking 1 - this gives us the probability of not going into sick, i.e. of staying in healthy instead).
# from Dead
# m_P_SoC["Dead", "Dead"] <- 1
# Once you're in dead you stay in dead, you can't come back to life.
# For handiness, we just take the treatment matrix that already exists for standard of care above, copy it as treatment A and treatment B, and then copy over it with new values specific to treatment A and treatment B, assuming that the probability of going from PFS to dead and staying in OS and going from OS to dead are the same as for standard of care (dead to dead is definitely the same as no one leaves dead) that's likely a reasonable assumption for our model, as once people progress we can assume they all go on to the same next treatment, standard of care progression treatment with the same likelihood of staying in OS and of going to the dead state, regardless of the novel therapy they were on:
# ## EPI Assay
# m_P_trtA <- m_P_SoC
# m_P_trtA["PFS", "PFS"] <- (1 - p_HD) * (1 - p_HS_trtA)
# m_P_trtA["PFS", "OS"]    <- (1 - p_HD) *      p_HS_trtA
#
# ## HDX Assay
# m_P_trtB <- m_P_SoC
# m_P_trtB["PFS", "PFS"] <- (1 - p_HD) * (1 - p_HS_trtB)
# m_P_trtB["PFS", "OS"]    <- (1 - p_HD) *      p_HS_trtB
# You can also think of it, per the 1hour: 05minute mark of: C:\Users\Jonathan\OneDrive - Royal College of Surgeons in Ireland\COLOSSUS\Training Resources\Cost-Effectiveness and Decision Modeling using R Workshop _ DARTH\August_24\Live Session Recording\Live Session Recording August 24th.mp4
# m_P_SoC["PFS", "OS"]    <- (1 - p_HD) [<- if you don't die] *      p_HS_SoC [then you have a risk of getting sick]
# It wont always be necessary to do this, i.e., to include conditional probabilities, it will depend on the data used and how things were estimated.
# This approach is taken for conditional probabilities, it's probably more relevant for modelling people to really, really old ages, where their mortality gets really high (so this is particularly relevant when you have age specific mortality), where you still have this high mortality of getting sick, you can end up in problems with the probabilities where the probability of leaving the state gets too high, because you haven't properly adjusted for these really high mortality rates, as people get really old.
# So, what this is doing is saying, if you don't die, then it's the remaining people who experience the probability of getting sick, so you're not adding probabilities together, which can be problematic, because sometimes you can have probabilities come to greater than one (i.e., larger than 100%).
# It's always worth considering, if you're extrapolating this risk of illness that's pretty high, on top of a cohort that also has a high risk of death, maybe that's not the right extrapolation, but this is another kind of fail safe to avoid that.
# Depending on how the data is estimated, this a correct interpretation of the probability estimate of going from one state to another (p_HS_SoC, or healthy to sick, or PFS to OS).
# Using conditional probabilities more generally is also discussed around the 1:04 hour mark of:
# C:\Users\Jonathan\OneDrive - Royal College of Surgeons in Ireland\COLOSSUS\Training Resources\Cost-Effectiveness and Decision Modeling using R Workshop \_ DARTH\August\_25\Live Session Recording\Live Session Recording August 25th WITH CHAT.mkv
# This is a check in the DARTH tools package that all the transition probabilities are in [0, 1], i.e., no probabilities are greater than 100%.
check_transition_probability(m_P_SoC,  verbose = TRUE)
check_transition_probability(m_P_Exp,  verbose = TRUE)
#check_transition_probability(m_P_trtA, verbose = TRUE)
#check_transition_probability(m_P_trtB, verbose = TRUE)
# Check that all rows sum in each matrix sum to 1 -> which we know is a necessary condition for transition probability matrices.
check_sum_of_transition_array(m_P_SoC,  n_states = n_states, n_cycles = n_cycle, verbose = TRUE)
l_params_all <- list(
coef_weibull_shape_SoC = coef_weibull_shape_SoC,
coef_weibull_scale_SoC = coef_weibull_scale_SoC,
HR_FP_Exp = HR_FP_Exp,
p_FD_SoC  = p_FD_SoC,
p_FD_Exp  = p_FD_Exp,
p_PD_SoC = p_PD_SoC,
p_PD_Exp = p_PD_Exp,
c_F_SoC   = c_F_SoC,
c_F_Exp   = c_F_Exp,
c_P       = c_P,
c_D       = c_D,
c_AE1 = c_AE1,
c_AE2 = c_AE2,
c_AE3 = c_AE3,
u_F = u_F,
u_P = u_P,
u_D = u_D,
u_AE1 = u_AE1,
u_AE2 = u_AE2,
u_AE3 = u_AE3,
d_e       = d_e,
d_c       = d_c,
n_cycle   = n_cycle,
t_cycle   = t_cycle
)
View(l_params_all)
View(l_params_all)
# Test function
oncologySemiMarkov(l_params_all = l_params_all, n_wtp = 20000)
# Test function
oncologySemiMarkov_function(l_params_all = l_params_all, n_wtp = 20000)
## 4.1 Initialization ----
# Load the model as a function that is defined in the supporting script
# source("Functions_markov_3state.R")
# Test function
# calculate_ce_out(l_params_all)
source(file = "oncologySemiMarkov_function.R")
# If I change any code in this main model code file, I will also need to update the function that I call.
# Test function
oncologySemiMarkov(l_params_all = l_params_all, n_wtp = 20000)
# Test function
oncologySemiMarkov(l_params_all = l_params_all, n_wtp = 20000)
## 4.1 Initialization ----
# Load the model as a function that is defined in the supporting script
# source("Functions_markov_3state.R")
# Test function
# calculate_ce_out(l_params_all)
source(file = "oncologySemiMarkov_function.R")
# If I change any code in this main model code file, I will also need to update the function that I call.
#
# l_params_all <- as.list(data.frame(
#   p_HD      = 0.01,  # probability of dying when OS
#   p_HS_SoC  = 0.05,  # probability of becoming PFS when OS, under standard of care
#   p_HS_trtA = 0.04,  # probability of becoming PFS when OS, under treatment A
#   p_HS_trtB = 0.02,  # probability of becoming PFS when OS, under treatment B
#   p_SD      = 0.1,   # probability of dying when PFS
#   c_H       = 400,   # cost of one cycle in OS state
#   c_S       = 1000,  # cost of one cycle in PFS state
#   c_D       = 0,     # cost of one cycle in dead state
#   c_trtA    = 800,   # cost of treatment A (per cycle)
#   c_trtB    = 1500,  # cost of treatment B (per cycle)
#   u_H       = 1,     # utility when OS
#   u_S       = 0.5,   # utility when PFS
#   u_D       = 0,     # utility when dead
#   d_e       = 0.04,  # discount factor for effectiveness
#   d_c       = 0.04   # discount factor for costs
# ))
#
# # store the parameter names into a vector
# v_names_params <- names(l_params_all)
# Test whether the function works (and generates the same results)
# - to do so, first a list of parameter values needs to be generated
# In Koen's code they manually set the value of things here, i.e.   HR_FP_Exp = 0.6, however, to support replicability I just set the variables equal to themselves for this list, and that way if I change something like HR_FP_Exp = 0.6, to HR_FP_Exp = 0.9 earlier in this R code it will automatically update here as well.
# I know that the values they used in this section were the same as their earlier values as they gave identical results when changed from manual values to setting the variable names equal to themselves, apart from .01 of a difference for NMB, but that's probably a rounding thing:
#
# > l_params_all <- list(
# +   coef_weibull_shape_SoC = 0.7700246,
# +   coef_weibull_scale_SoC = 1.742534,
# +   HR_FP_Exp = 0.6,
# +   p_FD      = 0.02,
# +   p_PD      = 0.1,
# +   c_F_SoC   = 400,
# +   c_F_Exp   = 800,
# +   c_P       = 1000,
# +   c_D       = 0,
# +   u_F       = 0.8,
# +   u_P       = 0.5,
# +   u_D       = 0,
# +   d_e       = 0.03,
# +   d_c       = 0.03,
# +   n_cycle   = 60,
# +   t_cycle   = 0.25
# + )
# >
# > oncologySemiMarkov(l_params_all = l_params_all, n_wtp = 20000)
#           Strategy     Cost   Effect      NMB
# 1 Standard of Care 11493.14 3.725848 63023.81
# 2     Experimental 18913.35 4.148299 64052.63
# > l_params_all <- list(
# +   coef_weibull_shape_SoC = coef_weibull_shape_SoC,
# +   coef_weibull_scale_SoC = coef_weibull_scale_SoC,
# +   HR_FP_Exp = HR_FP_Exp,
# +   p_FD      = p_FD,
# +   p_PD      = p_PD,
# +   c_F_SoC   = c_F_SoC,
# +   c_F_Exp   = c_F_Exp,
# +   c_P       = c_P,
# +   c_D       = c_D,
# +   u_F       = u_F,
# +   u_P       = u_P,
# +   u_D       = u_D,
# +   d_e       = d_e,
# +   d_c       = d_c,
# +   n_cycle   = n_cycle,
# +   t_cycle   = t_cycle
# + )
# > oncologySemiMarkov(l_params_all = l_params_all, n_wtp = 20000)
#           Strategy     Cost   Effect      NMB
# 1 Standard of Care 11493.14 3.725848 63023.82
# 2     Experimental 18913.35 4.148299 64052.64
# Now I update this list with the variables I have:
l_params_all <- list(
coef_weibull_shape_SoC = coef_weibull_shape_SoC,
coef_weibull_scale_SoC = coef_weibull_scale_SoC,
HR_FP_Exp = HR_FP_Exp,
p_FD_SoC  = p_FD_SoC,
p_FD_Exp  = p_FD_Exp,
p_PD_SoC = p_PD_SoC,
p_PD_Exp = p_PD_Exp,
c_F_SoC   = c_F_SoC,
c_F_Exp   = c_F_Exp,
c_P       = c_P,
c_D       = c_D,
c_AE1 = c_AE1,
c_AE2 = c_AE2,
c_AE3 = c_AE3,
u_F = u_F,
u_P = u_P,
u_D = u_D,
u_AE1 = u_AE1,
u_AE2 = u_AE2,
u_AE3 = u_AE3,
d_e       = d_e,
d_c       = d_c,
n_cycle   = n_cycle,
t_cycle   = t_cycle
)
# Test function
oncologySemiMarkov(l_params_all = l_params_all, n_wtp = 20000)
